<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="img/avatar.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Lei Xuelian</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/categories/开发工具/">玩转开发工具</a></li>
                        
                            <li><a  href="/categories/digital">玩转数码</a></li>
                        
                            <li><a  href="/categories/algorithm">算法学习</a></li>
                        
                            <li><a  href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="/xxxxx" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/web安全/" style="font-size: 12px;">web安全</a> <a href="/tags/渗透/" style="font-size: 10px;">渗透</a> <a href="/tags/渗透测试/" style="font-size: 18px;">渗透测试</a> <a href="/tags/系统安全/" style="font-size: 20px;">系统安全</a> <a href="/tags/网络/" style="font-size: 16px;">网络</a> <a href="/tags/网络安全/" style="font-size: 14px;">网络安全</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://weibo.com/u/5475514642/home?wvr=5&source=mozilla">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">爱工作、爱生活、更要好好爱自己!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Lei Xuelian</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="img/avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Lei Xuelian</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/categories/开发工具/">玩转开发工具</a></li>
                
                    <li><a href="/categories/digital">玩转数码</a></li>
                
                    <li><a href="/categories/algorithm">算法学习</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="/xxxxx" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-10-27-5.1发现主机" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/10/26/10-27-5.1发现主机/" class="article-date">
      <time datetime="2019-10-25T16:00:00.000Z" itemprop="datePublished">2019-10-26</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/10/26/10-27-5.1发现主机/">渗透测试之（五）信息收集（1）</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h2 id="5-1发现主机"><a href="#5-1发现主机" class="headerlink" title="5.1发现主机"></a>5.1发现主机</h2><p>​        发现主机是用来探测哪些主机是活动的，进而获取该主机的信息。用户可以使用主动扫描的方式发现主机，也可以采用被动监听的方式发现主机</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/渗透测试/">渗透测试</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a   href="/2019/10/26/10-27-5.1发现主机/#more">查看更多 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-10-13大马和小马" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/10/13/10-13大马和小马/" class="article-date">
      <time datetime="2019-10-12T16:00:00.000Z" itemprop="datePublished">2019-10-13</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/10/13/10-13大马和小马/">大马和小马</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <a id="more"></a>

<p>木马（Trojan）,也称木马病毒，是指通过特定的程序（木马程序）来控制另一台计算机。木马通常有两个可执行程序：一个是控制端，另一个是被控制端。木马这个名字来源于古希腊传说（荷马史诗中木马计的故事，Trojan一词的特洛伊木马本意是特洛伊的，即代指特洛伊木马，也就是木马计的故事）。“木马”程序是目前比较流行的病毒文件，与一般的病毒不同，它不会自我繁殖，也并不“刻意”地去感染其他文件，它通过将自身伪装吸引用户下载执行，向施种木马者提供打开被种主机的门户，使施种者可以任意毁坏、窃取被种者的文件，甚至远程操控被种主机。木马病毒的产生严重危害着现代网络的安全运行。</p>
<p>大马和小马的区别</p>
<p>答：小马体积小，容易隐藏，隐蔽性强，最重要在于与图片结合一起上传之后可以利用nginx或者IIS6的解析了漏洞来运行，不过功能少，一般只有上传功能</p>
<p>​        大马体积大，一般50K，功能也多，一般都包括提权命令，磁盘管理，数据库连接借口，执行名零零甚至有些已具备字代替全功能和压缩，解压缩网站程序的功能。这种马隐蔽性不好，而大多数如不加密的话很多杀毒厂商开始追杀此类程序</p>
<p>　<a href="https://www.baidu.com/s?wd=小马&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">小马</a>体积小，容易隐藏，隐蔽性强。大马体积比较大，功能多，危害大。</p>
<p>还有一种理解就是</p>
<p>​        小马是用来传大马的       有些网站为了防止传马做了限制  多少KB大马体积一般再300到100KB左右吧   而小马只有2KB<br>小马，实际上也就是一个小的上传在线保存文件  大马就是真正用于管理（**）或者提权的ASP文件。<br>先小后大的规则实际是上针对某些上传漏洞的限制而来的 假如有一个上传漏洞，可以帮你上传你的ASP文件 但又对上传文件的大小做了限制，这个时候直接上传你的大马就不行了 所以我们就需要实现一个不限制上传文件大小上传功能来替代现有的上传漏洞，这个怎么实现呢？ 也就是所说的小马了。 小马只是提供一个上传大马的页面，大马用于提权或者再上传更厉害的木马或后门     </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/渗透/">渗透</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-10-10爬虫问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/10/10/10-10爬虫问题/" class="article-date">
      <time datetime="2019-10-10T15:13:30.000Z" itemprop="datePublished">2019-10-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/10/10/10-10爬虫问题/">点击事件里后台打印数据闪现</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>今天在做爬虫项目时，有个搜索框和点击按钮，先把搜索框里面的值打印到后台，出现闪现问题，使用alert()时可以正常显示
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a   href="/2019/10/10/10-10爬虫问题/#more">查看更多 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-10-11图片未上传title python爬虫系列（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/10/10/10-11图片未上传title python爬虫系列（二）/" class="article-date">
      <time datetime="2019-10-09T16:00:00.000Z" itemprop="datePublished">2019-10-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/10/10/10-11图片未上传title python爬虫系列（二）/">python爬虫系列（二）</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <a id="more"></a>

<h2 id="什么是-XMLHttpRequest-对象？"><a href="#什么是-XMLHttpRequest-对象？" class="headerlink" title="什么是 XMLHttpRequest 对象？"></a>什么是 XMLHttpRequest 对象？</h2><p>XMLHttpRequest 对象用于在后台与服务器交换数据。</p>
<p>XMLHttpRequest 对象是<em>开发者的梦想</em>，因为您能够：</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
<p>XMLHttpRequest 为 ajax 的核心。</p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>XMLHttpRequest 本质及构成</li>
</ul>
<p>本质为一个函数；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> XMLHttpRequest ; <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure>

<p>onload =》请求成功时触发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open()</span><br></pre></td></tr></table></figure>

<p>代码部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 1通过异步实现sqlite的数据查询</span><br><span class="line">		var sql=&quot;select * from wallpaper&quot;</span><br><span class="line">		//申明一个异步对象,并实例化</span><br><span class="line">		var xhr=new XMLHttpRequest</span><br><span class="line">		//2请求准备</span><br><span class="line">		xhr.open(&apos;GET&apos;,&apos;wall_paper.db&apos;,true)</span><br><span class="line">		xhr.responseType=&apos;arraybuffer&apos;</span><br><span class="line">		//4请求成功后</span><br><span class="line">		xhr.onload=function(e)&#123;</span><br><span class="line">			//数据解析和数据解锁</span><br><span class="line">			//将结果转化为uint8array对象</span><br><span class="line">			var uint8array= new Uint8Array(this.response)</span><br><span class="line">			//将uint8array对象放入Database进行转换为sql的对象</span><br><span class="line">			var db =new SQL.Database(uint8array)</span><br><span class="line">			//执行sql并返回结果</span><br><span class="line">			var content=db.exec(sql)</span><br><span class="line">			console.log(content)</span><br><span class="line">			//开始便利解析数据</span><br><span class="line">			var result =content[0].values</span><br><span class="line">			var html=&quot;&quot;</span><br><span class="line">			if(result.length&gt;0)&#123;</span><br><span class="line">				for(var i=0;i&lt;result.length;i++)&#123;</span><br><span class="line">					// var title=result[i][0]</span><br><span class="line">					var image=result[i][2]</span><br><span class="line">					// var url=result[i][2]</span><br><span class="line">					//html+=&quot;&lt;div&gt;&lt;a herf=&apos;&quot;+url+&quot;&apos;&gt;&lt;img src=&apos;&quot;+image+&quot;&apos;&gt;&quot;+title+&quot;&lt;/img&gt;&lt;/a&gt;&lt;/div&gt;&quot;</span><br><span class="line">					html+=&quot;&lt;div&gt;&lt;img src=&apos;&quot;+image+&quot;&apos;/&gt;&lt;/div&gt;&quot;</span><br><span class="line">				&#125;</span><br><span class="line">				//向页面写出结果</span><br><span class="line">				console.log(html)</span><br><span class="line">				document.getElementById(&quot;left_content&quot;).innerHTML=html</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				//数据为空</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//3发起请求</span><br><span class="line">		xhr.send() //发送请求</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web安全/">web安全</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-10-07复习例题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/10/07/10-07复习例题/" class="article-date">
      <time datetime="2019-10-07T02:47:20.000Z" itemprop="datePublished">2019-10-07</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/10/07/10-07复习例题/">国庆复习（一）</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="一、例题"><a href="#一、例题" class="headerlink" title="一、例题"></a>一、例题</h1><p>1.VLAN是什么？有什么作用？<br>答：vlan可以理解为逻辑上划分广播域，可以降低广播风暴的产生    </p>
<p>1、VLAN是 一种将局域网（LAN）设备从逻辑上划分（注意，不是从物理上划分）成一个个网段（或者说是更小的局域网LAN），从而实现虚拟工作组（单元）的数据交换技术。 VLAN这一新兴技术主要应用于交换机和路由器中，但目前主流应用还是在交换机之中 。不过不是所有交换机都具有此功能，只有三层以上交换机才具有此功能，这一点可以查 看相应交换机的说明书即可得知。VLAN的好处主要有三个：<br>(1)端口的分隔。即便在同一个交换机上，处于不同VLAN的端口也是不能通信的。这<br>样一个物理的交换机可以当作多个逻辑的交换机使用。<br>(2)网络的安全。不同VLAN不能直接通信，杜绝了广播信息的不安全性。<br>(3)灵活的管理。更改用户所属的网络不必换端口和连线，只更改软件配置就可以了。<br>2、VLAN技术的出现，使得管理员根据实际应用需求，把同一物理局域网内的不同用户逻<br>辑地划分成不同的广播域，每一个VLAN都包含一组有着相同需求的计算机工作站，与物理<br>上形成的LAN有着相同的属性。由于它是从逻辑上划分，而不是从物理上划分，所以同一个<br>VLAN内的各个工作站没有限制在同一个物理范围中，即这些工作站可以在不同物理LAN网段 。由VLAN的特点可知，一个VLAN内部的广播和单播流量都不会转发到其他VLAN中，从而有 助于控制流量、减少设备投资、简化网络管理、提高网络的安全性。 VLAN除了能将网划 分为多个广播域，从而有效地控制广播风暴的发生，以及使网络的拓扑结构变得非常灵活<br>的优点外，还可以用于控制网络中不同部门、不同站点之间的互相访问。</p>
<p>2.VLAN的划分方法有哪些？<br>答：基于端口<br>     基于IP</p>
<p>VLAN在交换机上的实现方法，可以大致划分为4类：<br>　　（1） 基于端口划分的VLAN<br>　　这种划分VLAN的方法是根据<a href="https://www.baidu.com/s?wd=以太网交换机&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">以太网交换机</a>的端口来划分，比如Quidway S3526的1<del>4端口为VLAN 10，5</del>17为VLAN 20，18<del>24为VLAN 30，当然，这些属于同一VLAN的端口可以不连续，如何配置，由管理员决定，如果有多个交换机，例如，可以指定交换机 1 的1</del>6端口和交换机 2 的1~4端口为同一VLAN，即同一VLAN可以跨越数个<a href="https://www.baidu.com/s?wd=以太网交换机&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">以太网交换机</a>，根据端口划分是目前定义VLAN的最广泛的方法，IEEE 802.1Q规定了依据<a href="https://www.baidu.com/s?wd=以太网交换机&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">以太网交换机</a>的端口来划分VLAN的国际标准。<br>　　这种划分的方法的优点是定义VLAN成员时非常简单，只要将所有的端口都指定义一下就可以了。它的缺点是如果VLAN A的用户离开了原来的端口，到了一个新的交换机的某个端口，那么就必须重新定义。<br>　（2）基于MAC地址划分VLAN<br>　　这种划分VLAN的方法是根据每个主机的MAC地址来划分，即对每个MAC地址的主机都配置他属于哪个组。这种划分VLAN的方法的最大优点就是当用户物理位置移动时，即从一个交换机换到其他的交换机时，VLAN不用重新配置，所以，可以认为这种根据MAC地址的划分方法是基于用户的VLAN，这种方法的缺点是初始化时，所有的用户都必须进行配置，如果有几百个甚至上千个用户的话，配置是非常累的。而且这种划分的方法也导致了交换机执行效率的降低，因为在每一个交换机的端口都可能存在很多个VLAN组的成员，这样就无法限制广播包了。另外，对于使用笔记本电脑的用户来说，他们的网卡可能经常更换，这样，VLAN就必须不停的配置。<br>　　（3）基于网络层划分VLAN<br>　　这种划分VLAN的方法是根据每个主机的网络层地址或协议类型（如果支持多协议）划分的，虽然这种划分方法是根据网络地址，比如IP地址，但它不是路由，与网络层的路由毫无关系。它虽然查看每个数据包的IP地址，但由于不是路由，所以，没有RIP，OSPF等路由协议，而是根据生成树算法进行桥交换，<br>　　这种方法的优点是用户的物理位置改变了，不需要重新配置所属的VLAN，而且可以根据协议类型来划分VLAN，这对网络管理者来说很重要，还有，这种方法不需要附加的帧标签来识别VLAN，这样可以减少网络的通信量。<br>　　这种方法的缺点是效率低，因为检查每一个数据包的网络层地址是需要消耗处理时间的（相对于前面两种方法），一般的交换机芯片都可以自动检查网络上数据包的以太网祯头，但要让芯片能检查IP帧头，需要更高的技术，同时也更费时。当然，这与各个厂商的实现方法有关。<br>　　（4）根据<a href="https://www.baidu.com/s?wd=IP组播&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">IP组播</a>划分VLAN<br>　　IP 组播实际上也是一种VLAN的定义，即认为一个组播组就是一个VLAN，这种划分的方法将VLAN扩大到了广域网，因此这种方法具有更大的灵活性，而且也很容易通过路由器进行扩展，当然这种方法不适合局域网，主要是效率不高。<br>　　鉴于当前业界VLAN发展的趋势，考虑到各种VLAN划分方式的优缺点，为了最大程度上地满足用户在具体使用过程中需求，减轻用户在VLAN的具体使用和维护中的工作量，Quidway S系列交换机采用根据端口来划分VLAN的方法。</p>
<p>3.为什么要做冗余链路？冗余链路会带来什么问题？<br>答：冗余链路可以使PC消息多种路径转发 问题：会造成链路中有浪费</p>
<p>使用<a href="https://www.baidu.com/s?wd=冗余链路&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">冗余链路</a>是为了防止单点故障，如果一条线路故障了另一条还可以继续工作保障通信正常。<a href="https://www.baidu.com/s?wd=冗余链路&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">冗余链路</a>是物理上的线路冗余，至于技术上主要是STP（<a href="https://www.baidu.com/s?wd=生成树协议&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">生成树协议</a>）。这个是为了防止链路冗余造成环路设计的。</p>
<p>4.怎么避免环路？<br>答：可以在交换机中设置主副 primary secondery 然后链路聚合    //使用生成树协议</p>
<p>5.STP是什么？有什么作用？有哪些类型？以及每种类型的特点是什么？<br>答：生成树协议<br>6.STP的工作过程是怎么样的？</p>
<p>7.STP端口有哪些状态？每种状态的能力是什么？</p>
<p><strong>Blocking（阻塞状态）：</strong>此时，二层端口为非指定端口，也不会参与数据帧的转发。该端口通过接收BPDU来判断根交换机的位置和根ID，以及在STP拓扑收敛结束之后，各交换机端口应该处于什么状态，在默认情况下，端口会在这种状态下停留20秒钟时间。</p>
<p><strong>Listening（侦听状态）：</strong>生成树此时已经根据交换机所接收到的BPDU而判断出了这个端口应该参与数据帧的转发。于是交换机端口就将不再满足于接收BPDU，而同时也开始发送自己的BPDU，并以此通告邻接的交换机该端口会在活动拓扑中参与转发数据帧的工作。在默认情况下，该端口会在这种状态下停留15秒钟的时间。</p>
<p><strong>Learning(学习状态)：</strong>这个二层端口准备参与数据帧的转发，并开始填写MAC表。在默认情况下，端口会在这种状态下停留15秒钟时间。</p>
<p><strong>Forwarding（转发状态）：</strong>这个二层端口已经成为了活动拓扑的一个组成部分，它会转发数据帧，并同时收发BPDU。</p>
<p><strong>Disabled（禁用状态）：</strong>这个二层端口不会参与生成树，也不会转发数据帧。</p>
<p>8.100Mps的和10Mps在STP中COST值是多少？<br>答：100M的cost值为19</p>
<p>​        10Mps为100</p>
<p>9.本征VLAN是什么？有什么作用？</p>
<p>native VLAN存在的原因主要是支持VLAN与不支持VLAN的设备相互兼容，大部分计算机网卡、集线器等设备不能识别带VLAN标签的数据帧，只有去掉VLAN标签，这些设备才能正确识别数据帧。</p>
<p>提到native VLAN存在的原因常会举这样的例子，对STP协议数据打上VLAN标签会让不支持VLAN的交换机无法识别，最终STP协议无法工作，所以需要native VLAN将VLAN标签去掉在发送。</p>
<p>这个例子实际上是新老设备兼容性问题，STP协议（802.1D）是1990年发布，802.1Q协议是1998年发布， VLAN概念出现的比较晚，老设备不支持802.1Q协议不能识别带VLAN标签的数据，所以新设备要具备去掉VLAN标签的能力， native  VLAN就出现了。</p>
<p>网络技术进步很快，距离802.1Q协议发布已经过去20多年，这个兼容性问题现在基本不存在了。</p>
<p>10.链路聚合协议有哪两种？端口模式分别有哪些？两端端口哪些模式可以实现聚合？</p>
<p>11.链路聚合如果是三条100Mps的带宽，聚合后的信道带宽是多少？<br>答：300M<br>12.svi接口时什么接口？ //虚拟vlan的网关接口<br>答：vlan<br>13.VTP有几种模式？每种模式有什么区别？<br>答：<br>14.层三交换机和层二交换机有什么区别？<br>答：二层交换机在设置trunk时 本身自带封装，而三层交换机在设置trunk时会提示所有端口都是auto模式，设置不了，此时就必须设置封装 802.1<br>15.交换机的工作原理时什么？以及交换机的三种转发模式是什么？<br>答：原理：PC机在发送消息时，会携带自身的MAC地址，交换机在自己的的范围内广播这些消息，对应的PC机收到消息也会携带自身的MAC地址作出回应。 模式：protect\restrict\shutdown<br>16.172.16.0.78/25，请问网络号是多少？本网络有多少个可用IP？<br> 答：网络号：172.16.0.0/25     本网络有126个可用IP</p>
<p>17.vlsm是什么？</p>
<p>18.IP地址分类？有哪几类？<br> 答：A、B、C、D、E</p>
<p>19.每类中的私有IP范围是多少？</p>
<p>20.ICMP的类型有哪些？目标不可达和超时类型分别是什么？</p>
<h1 id="二、知识点："><a href="#二、知识点：" class="headerlink" title="二、知识点："></a>二、知识点：</h1><h2 id="（一）STP原理，用途，类型"><a href="#（一）STP原理，用途，类型" class="headerlink" title="（一）STP原理，用途，类型"></a>（一）STP原理，用途，类型</h2><p>1、【原理】</p>
<p> 通过选择性逻辑关闭端口传输来实现。</p>
<p>具体是根据：<br> 选取一个根桥，然后在非根桥交换机上选出根端口和指定端口，<br> 最后选出阻塞端口将其阻塞。</p>
<p>选举是根据传递BPDU的信息，桥协议数据单元来实现的。<br>BPDU里主要有：<br> 根端口ID，链路开销，桥ID，端口ID。<br> 通过比较上述内容来实现。 </p>
<p><strong>生成树协议</strong>（英语：<strong>Spanning Tree Protocol</strong>，<strong>STP</strong>），是一种工作在OSI网络模型中的第二层数据链路层的通信协议，基本应用是防止交换机冗余链路产生的环路.用于确保以太网中无环路的逻辑拓扑结构.从而避免了广播风暴,大量占用交换机的资源.</p>
<p>生成树协议工作原理:任意一交换机中如果到达根网桥有两条或者两条以上的链路.生成树协议都根据算法把其中一条切断,仅保留一条.从而保证任意两个交换机之间只有一条单一的活动链路.因为这种生成的这种拓扑结构.很像是以根交换机为树干的树形结构.故为生成树协议</p>
<p>生成树协议是基于Radia Perlman在<a href="https://baike.baidu.com/item/DEC" target="_blank" rel="noopener">DEC</a>工作时发明的一种算法被纳入了IEEE 802.1d中，2001年IEEE组织推出了快速生成树协议(RSTP)在网络结构发生变化时其比STP更快的收敛网络,还引进了端口角色来完善了收敛机制,被纳入在IEEE 802.1w中.</p>
<p>STP的工作过程如下：首先进行根网桥的选举，其依据是网桥优先级（bridge  priority）和MAC地址组合生成的桥ID，桥ID最小的网桥将成为网络中的根桥（bridge  root）。在此基础上，计算每个节点到根桥的距离，并由这些路径得到各冗余链路的代价，选择最小的成为通信路径（相应的端口状态变为forwarding），其它的就成为备份路径(相应的端口状态变为blocking)。STP生成过程中的通信任务由BPDU完成，这种数据包又分为包含配置信息的配置BPDU（其大小不超过35B）和包含拓扑变化信息的通知BPDU（其长度不超过4B）。</p>
<p>五种状态：</p>
<p>ｄｏｗｎ<br> 阻塞<br> 侦听<br> 学习<br> 转发</p>
<table>
<thead>
<tr>
<th>端口状态</th>
<th>端口能力</th>
</tr>
</thead>
<tbody><tr>
<td>Disabled</td>
<td>不收发任何报文</td>
</tr>
<tr>
<td>Blocking</td>
<td>不接收或者转发数据，接收但不发送BPDU，不进行地址学习</td>
</tr>
<tr>
<td>Listening</td>
<td>不接收或者转发数据，接收并发送BPDU，不进行地址学习</td>
</tr>
<tr>
<td>Learning</td>
<td>不接收或者转发数据，接收并发送BPDU，开始进行地址学习</td>
</tr>
<tr>
<td>Forwarding</td>
<td>接收或者转发数据，接收并发送BPDU，进行地址学习</td>
</tr>
</tbody></table>
<p>【用途】<br> STP应用于第二层。</p>
<p>用途是消除网络环路，达到更好的冗余。<br>【类型】 </p>
<p>STP，RSTP，MSTP 公有组织。<br> PVST+，PVRST，cisco</p>
<p>2、STP的工作原理和作用</p>
<p>STP的基本原理是通过在交换机之间传递一种特殊的协议报文，网桥协议数据单元（简称BPDU），来确定网络的拓扑结构。BPDU有两种，配置BPDU（和TCN BPDU）。前者是用于计算无环的生成树的，后者则是用于在二层网络拓扑发生变化时产生用来缩短MAC表项的刷新时间的。</p>
<p>STP的作用：可应用于计算机网络中树形拓扑结构建立，主要作用是防止网桥网络中的冗余链路形成环路工作，即能解决了核心层网络需要冗余链路的网络健壮性要求，又能解决因为冗余链路形成的物理环路导致“广播风暴”问题。</p>
<p>3、扩展资料：</p>
<p>STP的潜在故障</p>
<p>A、生成树算法不稳定</p>
<p>STP协议工作在第二层，在交换机端口之间传递网络协议单元获取网络拓扑，并通过STA算法阻断环路形成树形逻辑网络拓扑。但如果网络拓扑过于复杂，STA算法有时会存在失效的情况，这时根桥、根端口和指定端口的选举失败，导致环路的产生，使网络瘫痪。</p>
<p>B、端口工作方式导致端口工作模式不匹配</p>
<p>工作在全双工模式下的端口在发送数据前不载波侦听链路是否处于空闲状态，直接发送数据，而工作在半双工模式下的端口在发送数据前先执行载波侦听且当链路处于空闲状态时才发送数据，此时，全双工端口持续性的有大量数据需要发送，那么半双工状态的端口将不会有数据传送给对端。</p>
<p>C、单向链路故障</p>
<p>在采用光纤为通信介质的网络中，往往采用两组光纤收发链路来保证网络的可靠性和稳定性。单链路故障影响了STP的网桥协议单元的发送，致使STA计算出现错误码，将本应处于阻断状态的端口转变为转发状态，从而导致环路的产生。</p>
<h2 id="（二）STP潜在故障"><a href="#（二）STP潜在故障" class="headerlink" title="（二）STP潜在故障"></a>（二）STP潜在故障</h2><p><strong>1、生成树算法不稳定</strong></p>
<p>STP协议工作在第二层，在交换机端口之间传递网络协议单元获取网络拓扑，并通过STA算法阻断环路形成树形逻辑网络拓扑。但如果网络拓扑过于复杂，STA算法有时会存在失效的情况，这时根桥、根端口和指定端口的选举失败，导致环路的产生，使网络瘫痪。这一问题的根本原因理论上还无定论，多数人认为是STP协议本身不稳定的问题，比如STP生成树收敛过慢，导致网络协议单元数据包丢失过多，STA误以为网络中出现了单点故障，从而使处于阻塞状态的端口变为转发状态，网络出现环路导致网络瘫痪。此种故障出现的概率很低，但出现了很难排除。</p>
<p><strong>2、端口工作方式导致端口工作模式不匹配</strong></p>
<p>交换机的端口工作模式有单工（Simplex）、半双工（half-duplex）和全双工（full-duplex）三种模式，一般在配置时都采用自动协商的方式。在配置时如果将交换机一端人工设置为全双工，另一端仍然采用自动协商方式，在有些品牌的交换机中，将使通信链路在半双工模式下工作；更有一种极端的方式，将一端交换机的端口工作方式设置为全双工模式，而将链路对端交换机的端口设置为半双工模式，这都会导致双工不匹配的问题。其结果是工作在全双工模式下的端口在发送数据前不载波侦听链路是否处于空闲状态，直接发送数据，而工作在半双工模式下的端口在发送数据前先执行载波侦听且当链路处于空闲状态时才发送数据，此时，如果全双工端口持续性的有大量数据需要发送，那么半双工状态的端口将不会有数据传送给对端。STA在计算的时候，由于半双工状态的端口发送不了网络协议单元，STA会将处于阻塞状态的端口打开，从而形成环路。</p>
<p><strong>3、单向链路故障</strong></p>
<p>在采用光纤为通信介质的网络中，往往采用两组光纤收发链路来保证网络的可靠性和稳定性（一组通信，一组冗余），由于光纤收发器的故障、任意一组收发对中的某一条链路故障或者两组链路中的某一条链路出现了交叉连接，都会导致本端收发器能收到对端收发器发送的报文，便对端收发器收不到本端收发器发送的报文，这种故障称为单链路现象，隐蔽性高，不易排错。由于单链路故障影响了STP的网桥协议单元的发送，致使STA计算出现错误码，将本应处于阻断状态的端口转变为转发状态，从而导致环路的产生。</p>
<p><strong>4、数据帧被损坏</strong></p>
<p>交换机是二层通信，如果物理链路的通信质量不高（通信介质质量问题或干扰问题等），将导致数据帧在传输时被损坏，从而被丢弃。网桥协议单元在传输时因信道质量不高而损坏达到一定量后，会使STA误认为出现单点故障而将已阻断的端口打开通信。一般对于STP协议来讲，如果阻塞端口丢失网桥协议单元的状态超过50秒，就会出现故障。</p>
<p><strong>5、网络设备资源不足引起故障</strong></p>
<p>STP协议的执行及其网桥协议单元的处理都由网络设备（主要是交换机）的CPU来进行，如果交换机的CPU本身处理能力不强或被其他问题过渡占用，使交换机无法及时发出或接收网桥协议单元，引起STP无法正常工作的故障。</p>
<p><strong>6、配置Por tFast快速端口引起的故障</strong></p>
<p>在运行STP的网络中，如果将交换机上直接连接主机的端口配置为Port   Fast，可以使端口直接从阻断状态转变为转发状态，从而使STP网络快速收敛。如果网络管理员在配置交换机是，将用于连接其他交换机的某个端口也设置为Port  Fast，那么当该端口被启用时会直接进入转发状态，从而导致网络中短时存在环路，当环路中的数据流量相当大时，网络会瘫痪 [2]  。</p>
<h2 id="（三）SVI"><a href="#（三）SVI" class="headerlink" title="（三）SVI"></a>（三）SVI</h2><p> SVI:（switch virtualinterface）交换机虚拟接口既交互三级的管理Vlan 地址<br>　　svi有两种类型：</p>
<p>　　一、主机管理接口。管理员可以利用该接口管理交换机。</p>
<p>　　二、网关接口。用于三层交换机跨vlan间路由。具体可以用interface　vlan接口配置命令来创建svi,然后为其配置ip地址即可实现路由功能。　</p>
<p>​        一个交换机虚拟接口（Switch Virtual Interface，SVI）代表一个由交换端口构成的VLAN（其实就是通常所说的VLAN接口），以便于实现系统中路由和桥接的功能。一个交换机虚拟接口对应一个VLAN，当需要路由虚拟局域网之间的流量或桥接VLAN之间不可路由的协议，以及提供IP主机到交换机的连接的时候，就需要为相应的虚拟局域网配置相应的交换机虚拟接口，其实SVI就是指通常所说的VLAN接口，只不过它是虚拟的，用于连接整个VLAN，所以通常也把这种接口称为逻辑三层接口，也是三层接口。SVI接口是当在interface vlan全局配置命令后面键入具体的VLAN ID时创建的。可以用no interface vlan vlan_id全局配置命令来删除对应的SVI接口，只是不能删除VLAN 1的SVI接口（VLAN 1），因为VLAN 1接口是默认已创建的，用于远程交换机管理。应当为所有VLAN配置SVI接口，以便在VLAN间路由通信。也就是SVI接口的用途就是为VLAN间提供通信路由。</p>
<p>　　一个VLAN仅可以有一个SVI。在你希望在VLAN之间进行路由，或者在VLAN间进行非路由协议的fallback桥接，或者提供IP主机连接到交换机时，就需要为VLAN配置一个SVI。默认情况下，SVI是为默认VLAN（通常是VLAN1）而创建的，以允许进行远程交换机管理。其他的SVI必须明确配置。所以说，SVI接口可以同时是该交换机的管理接口和下层设备的网关接口（路由连接口）。SVI提供到系统的IP主机连接。在三层模式中，可以配置通过SVI的路由。</p>
<p>　　SVI是在你为VLAN接口第一次键入vlan接口配置命令时创建的。VLAN与ISL或IEEE 802.1q协议中封装的中继，或者访问端口配置的VLAN ID的数据帧相关联的VLAN标记相对应。如果需要路由VLAN间的通信，则需要为每个VLAN配置一个VLAN接口（也就是这里所说的SVI），并为每个SVI接口分配一个IP地址。</p>
<p>　　SVI具有自动状态排除（Autostate Exclude）特征。带有多个端口的VLAN上的SVI线路状态在SVI接口满足以下条件时呈开启状态：</p>
<p>　　VLAN存在，并且在交换机的VLAN数据库中呈激活状态。</p>
<p>　　VLAN接口存在，并且是可管理的。</p>
<p>　　在VLAN中至少存在一个二层端口（访问端口或中继端口）的链路呈开启状态，并且这个链路在VLAN中是在生成树转发状态（Spanning-tree<br>　　forwarding State）中。</p>
<p>　　默认情况下，在一个VLAN有多个端口时，VLAN中的所有端口关闭后，SVI接口也将关闭。可以使用SVI自动状态排除特征来配置端口，使它不包括在SVI接口状态开关考虑范围内。例如，如果在VLAN中只有一个激活端口是镜像端口，则可以在该端口上配置自动状态排除，以便在所有其他端口关闭时关闭VLAN。在启用一个端口时，自动状态排除特征将应用到该端口上所连的所有已启用的VLAN中。   </p>
<h2 id="（四）二层交换机与三层交换机的区别"><a href="#（四）二层交换机与三层交换机的区别" class="headerlink" title="（四）二层交换机与三层交换机的区别"></a>（四）二层交换机与三层交换机的区别</h2><p>我们习惯说，在二层网络环境中相同vlan之间可以通信，不同vlan之间不可以通信，如果想通信必须借助三层设备，所以说三层交换机必须要做的事情是路由转发，但是二、三层交换机具体有什么区别呢？</p>
<p>二层交换机工作于OSI模型的第2层(数据链路层)，故而称为二层交换机。</p>
<p>二层交换技术发展比较成熟，二层交换机属数据链路层设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。具体的工作流程如下：</p>
<p>（1） 当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的；</p>
<p>（2） 再去读取包头中的目的MAC地址，并在地址表中查找相应的端口；</p>
<p>（3） 如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上；</p>
<p>（4） 如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。</p>
<p>不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。</p>
<p>二层交换技术从网桥发展到VLAN（虚拟局域网），在局域网建设和改造中得到了广泛的应用。第二层交换技术是工作在OSI七层网络模型中的第二层，即数据链路层。它按照所接收到数据包的目的MAC地址来进行转发，对于网络层或者高层协议来说是透明的。它不处理网络层的IP地址，不处理高层协议的诸如TCP、UDP的端口地址，<strong>它只需要数据包的物理地址即MAC地址，数据交换是靠硬件来实现的，其速度相当快，这是二层交换的一个显著的优点。但是，它不能处理不同IP子网之间的数据交换</strong>。<strong>传统的路由器可以处理大量的跨越IP子网的数据包，但是它的转发效率比二层低</strong>，因此要想利用二层转发效率高这一优点，又要处理三层IP数据包，三层交换技术就诞生了。</p>
<p>三层交换（也称多层交换技术，或IP交换技术）是相对于传统交换概念而提出的。众所周知，传统的交换技术是在OSI网络标准模型中的第二层——数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发。简单地说，<strong>三层交换技术就是：二层交换技术＋三层转发技术。</strong></p>
<p><strong>三层交换机就是具有部分路由器功能的交换机。</strong></p>
<p>三层交换机的最重要目的<strong>是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发</strong>。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。三层交换技术就是二层交换技术+三层转发技术。</p>
<p>三层交换技术的出现，解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。</p>
<p>举个栗子，在上课的时候学生偷偷传纸条，当一个男生偷偷传张纸条给女生，女生这时候会干嘛？是要打开纸条查看里面写了什么内容吧！三层交换机在接收到目的mac地址是自己的时候要做的事情也是向上层解封装，查看三层目的IP地址，然后呢？</p>
<p>女生打开，上面写着“请将纸条递给下一个人”，三层交换机也是这样一看原来目的IP地址不是自己，这才执行路由层面的转发；所以说交换机在执行要不要三层转发，是在目的mac是自己的同时，IP地址是不是自己，如果是自己那还转发个啥来，就不用转发了。</p>
<p>交换机在判断出目的IP不是自己的时候是不是一定就去查看路由表呢 ？不是，这个就是交换机的关键所在了，交换机此时不会查看路由表，不会查看arp表，不会查看mac地址表；那交换机会查看什么表？</p>
<p>交换机此时会查看自己集成在ASIC硬件转发卡中的硬件转发表，那这个硬件转发表都包含了什么内容呢？</p>
<p>当第一个包过来的时候，发现硬件转发表并没有什么表项，所以此时必须将数据包交由路由进程处理，一旦交由cpu处理，必然会消耗cpu资源，此时会查看路由表，然后发现此IP地址个自己是直连的，此时就去查看arp找出此地址对应的mac地址，就可以转发出去了在决定转发出去过程中，交换机至少会做三件事情，一，修改IP包头的ttl值；二，修改原mac地址，改成自己出接口mac地址；三，建立交换机硬件转发表，包括目的IP地址，目的IP地址（下一跳）对应的mac地址，mac地址对应的vlan，以及对应的端口（这个每个厂家有自己的理解）这样当一下包过来的时候，交换机就会查看硬件转发表直接转发而不会在经过路由表的查询了，也即是交换机的一次路由，多次交换机原理。</p>
<p>总之，二层交换机用于小型的局域网络。这个就不用多言了，在小型局域网中，广播包影响不大，二层交换机的快速交换功能、多个接入端口和低廉价格为小型网络用户提供了很完善的解决方案。</p>
<p>而三层交换机的最重要的功能是加快大型局域网络内部的数据的快速转发，加入路由功能也是为这个目的服务的。如果把大型网络按照部门，地域等等因素划分成一个个小局域网，这将导致大量的网际互访，<strong>单纯的使用二层交换机不能实现网际互访；如单纯的使用路由器，由于接口数量有限和路由转发速度慢，将限制网络的速度和网络规模，采用具有路由功能的快速转发的三层交换机就成为首选。</strong></p>
<p>一般来说，在内网数据流量大，要求快速转发响应的网络中，如全部由三层交换机来做这个工作，会造成三层交换机负担过重，响应速度受影响，将网间的路由交由路由器去完成，充分发挥不同设备的优点，不失为一种好的组网策略，当然，前提是你的腰包很鼓，不然就退而求其次，让三层交换机也兼为网际互连。</p>
<p>传统交换技术是在OSI网络标准模型第二层–数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发，既可实现网络路由功能，又可根据不同网络状况做到最优网络性能。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-09-18linux shell脚本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/09/24/09-18linux shell脚本/" class="article-date">
      <time datetime="2019-09-24T14:07:30.328Z" itemprop="datePublished">2019-09-24</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>linux shell脚本</p>
<p>shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，<br>主要是方便管理员进行设置或者管理用的。相对于Perl、Python等脚本语言优势在于它能处理底层业务，<br>因为有大量Linux命令作为支撑，“自动安装”等用shell脚本写就会非常简单。</p>
<p>Linux下的shell脚本默认为bash ，sh其实是bash的一个链接。</p>
<p>1）查看默认shell的两种方法:<br>1）echo $SHELL<br>/bin/bash</p>
<p>2）grep root /etc/passwd<br>root:x:0:0:root:/root:/bin/bash</p>
<p>（2）样例脚本：<br>基于这个脚本来学习一下简单的shell脚本。</p>
<p>#!bin/bash</p>
<p>#变量定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ETC_DIR=/etc/sysconfig/network-scripts</span><br><span class="line">NET_DIR=/etc/sysconfig</span><br><span class="line">ROOT_UID=0</span><br></pre></td></tr></table></figure>

<p>#if条件判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]  #判断是否为root权限</span><br><span class="line">then</span><br><span class="line">   echo &quot;Must be root to run this script&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd $ETC_DIR || &#123;</span><br><span class="line">    echo &quot;Cannot change to necessary directory,&quot;&gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#清除原来的网卡配置文件</p>
<p>cat /dev/null  &gt;ifcfg-eth0 &amp;&amp; echo “clean ifcfg-eth0 ok!”</p>
<p>#写入eth0配置：init_ip是先编辑好的网卡配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /root/init_ip &gt;ifcfg-eth0 &amp;&amp; echo &quot;write eth0 sucessfully&quot;</span><br><span class="line">cd $NET_DIR || &#123;</span><br><span class="line">    echo &quot;Cannot change to necessary directory,&quot;&gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service network restart   #重启网络命令<br>exit 0  #返回成功</p>
<p>（2）UID说明<br>UID是一个系统变量，当前是root权限 UID=0，当前非root权限UID不等于0<br>所以我们在这设置了一个变量ROOT_UID=0,来判断当前是否为root状态，因为我们对系统的配置文件进行修改必须使用root权限。所以执行的时候必须加sudo。</p>
<p>脚本执行时候会先调用环境变量，去找相关变量，有的变量是系统已经定义可直接使用，如上文用到的UID。<br>1）cat /etc/profile     （全局）<br>2）cat /etc/profile.d   （全局）可以把变量放在这里面就可以直接用<br>3）.bashrc：用户环境变量<br>4）.bash_profile：用户环境变量</p>
<p>（3）清空文件的三种方法：<br>清空日志的三种方法：<br>1、echo “”&gt;test.log<br>2、echo  &gt;test.log<br>3、cat /dev/null &gt;test.log</p>
<p>/dev/null称之为黑洞<br>在代码中用的是第三种方法：cat /dev/null &gt;network</p>
<p>（4）&amp;&amp;与||的使用：<br>cat /dev/null  &gt;ifcfg-eth0 &amp;&amp; echo “clean ifcfg-eth0 ok!”</p>
<p><a href>1.&amp;&amp;表示只有当前面的命令执行成功以后才执行后面的命令。<br>2.||表示前面执行不成功就执行后面命令。</a><br>在这两个符号后面，用大括号，可以写入多条命令<br>cd $NET_DIR || {<br>    echo “Cannot change to necessary directory,”&gt;&amp;2<br>    exit 1<br>}</p>
<p>如果不能够进入到该目录下，就打印错误信息。<br>1）&amp;0表示标准输入。<br>2）&amp;1表示标准输出。<br>3）&amp;2表示标准出错，</p>
<p>（5）脚本执行的三种方法：<br>1）bash或sh + 脚本名     （文件无可执行权限，或者没指定解释器）<br>2）绝对路径/脚本名     （需要可执行权限）或者./（和第一种方法类似，不过需要可执行权限）<br>3）source +脚本名 或者. 脚本名</p>
<p>bash或sh 指定的bash执行脚本，然后启动子shell去执行,比如，没有在脚本第一行指定使用哪一种脚本命令，就要在执行时指定解释器。<br>一般脚本都会在第一行写上‘#!/bin/bash’,且只能放在第一行，放在其他行就作注释处理，则需要用使用第一种方法。但是在Linux系统默认是bash，所以无需指定也可以，但是在其他系统就不行了。</p>
<p>（6）source xxx.sh<br>source和.命令是Shell的内建命令，这种方式也不会创建子Shell,直接在当前的shell中执行，并且调用系统默认的shell去执行脚本，不管脚本中是不是指定shell命令解析器。<br>source和.命令不启动子shell，所以会直接执行子shell里的语句，并把变量传给父shell。脚本里面所有新建、改变变量的语句都会保存在当前shell里面。</p>
<p>一、常见变量</p>
<p>不同于其它语言需要先声明变量，shell的变量直接使用，eg:a=15   echo $a （该命令可提出出a的值）<br>调用变量的话 $a 或者 ${a}。 ${a} 可实现字符串拼接</p>
<p>​       </p>
<pre><code>$?    #判断上一条命令执行的是否成功，执行成功返回0，失败返回1

$0    #返回脚本的文件名称

$1-$9 #返回对应的参数值

$* #返回所有的参数值是什么

$# #返回参数的个数和</code></pre><p>编写脚本如下：</p>
<pre><code>#test
#!/bin/bash
#by xuhan 2019-3
#test
echo &quot;this is my first shell&quot;

echo &quot;脚本名称：$0&quot;
echo &quot;第一个参数：$1&quot;
echo &quot;第二个参数：$2&quot;
echo “所有的参数值：$* ”
echo &quot;参数的个数和：$#&quot;
~</code></pre><p>添加测试用例结果如下：</p>
<p>二、常见的几个符号</p>
<blockquote>
<p>#会覆盖原有的内容</p>
</blockquote>
<blockquote>
<blockquote>
<p>#不会覆盖原有的内容</p>
</blockquote>
</blockquote>
<p>;    #执行多条命令</p>
<p>|    #管道符</p>
<p>&amp;&amp; #前面的命令执行成功，后面的才可以执行</p>
<p>|| #前面的命令执行失败，后面的才可以执行</p>
<p> “” #会输出变量值</p>
<p> ‘’ #输出本身</p>
<p>`` #输出命令结果 eg:a=<code>date</code>;echo $a</p>
<p>2&gt;/dev/null  #错误输出到无底洞</p>
<p>1&gt;/dev/null  #正确输出到无底洞</p>
<p>​              </p>
<p><a href="https://www.jb51.net/article/134292.htm" target="_blank" rel="noopener">https://www.jb51.net/article/134292.htm</a></p>
<p>1、单行注释：#</p>
<p>2、多行注释</p>
<p>方法一（这是比较稳妥的作法）：可以采用 HERE DOCUMENT 特性，实现多行注释，比如</p>
<pre><code>&lt;&lt;&apos;COMMENT&apos;
...

COMMENT</code></pre><p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Say Something&quot;</span><br><span class="line">&lt;&lt;COMMENT</span><br><span class="line">    your comment 1</span><br><span class="line">    comment 2</span><br><span class="line">    blah</span><br><span class="line">COMMENT</span><br><span class="line">echo &quot;Do something else&quot;</span><br></pre></td></tr></table></figure>

<p>方法二 </p>
<p>直接采用 : 这个命令的特殊作用，但这种做法有很多局限性，而且会影响性能，下面会介绍它的原理及性能分析。</p>
<p>如下是最简单的使用方法:</p>
<pre><code>: &apos;
COMMENT1
COMMENT2
&apos;</code></pre><p>即 : + 空格 + 单引号。</p>
<p>解释如下：</p>
<p>首先要知道 : 在 shell 中的特殊作用，它是内置的命令，先看一下它的帮助说明：</p>
<pre><code>$ help :
:: :
Null command.
No effect; the command does nothing.
Exit Status:
Always succeeds.</code></pre><p>即，:  它也是一个命令，既然是命令就会可以给它传参数，但因它会过滤掉这些参数，而单引号括起来的是普通的代码部分表示字符串，所以我们刚好可将来用来代表注释，表示在 : 后的 单引号括起来的部分在程序执行的时候忽略。</p>
<p>另外如果不好理解，直接把它当作汇编中的 NOP， python 中的 pass ，它只是一个占位，每次返回都是真，即 $? 的话，结果会是 0 。</p>
<p>如此一来，此方法是不是很绝妙？ 但事实上里面潜藏着很多问题：</p>
<pre><code>它不会注释 shell 脚本中本身带有单引号的语句部分，除非你将程序中的单引号全部换成双引号，这样不爽。
还是就是，虽然 : 会忽视后面的参数，但其实参数部分还是可能会被执行些操作，比如替换操作，文件截取操作等。所以这样会影响到代码的执行效率。
例如：
: &gt; file 会截取 file 。
: $(dangerous command) 这个替换操作照样会执行。</code></pre><p>所以第二种方法，只能临时用用。</p>
<p>第三种方法，即：采用 : + &lt;&lt; ‘COMMENT’ 的方式。</p>
<pre><code>#!/bin/bash
echo &quot;Say Something&quot;
: &lt;&lt;&apos;COMMENT&apos;
    your comment 1
    comment 2
    blah
COMMENT
echo &quot;Do something else&quot;</code></pre><p>注意：要加上单引号部分，有时候虽然不加不会有什么问题，但还是要加，以防出现莫名其妙的意外发生，比如发生字符扩展，命令替换等。</p>
<p>但最保险的方法还是每行前加上 #</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-09-24第一章爬虫" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/09/24/09-24第一章爬虫/" class="article-date">
      <time datetime="2019-09-23T16:00:00.000Z" itemprop="datePublished">2019-09-24</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/09/24/09-24第一章爬虫/">初识python</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>浅谈python</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web安全/">web安全</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a   href="/2019/09/24/09-24第一章爬虫/#more">查看更多 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-09-09Linux下的磁盘分区和逻辑卷" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/09/09/09-09Linux下的磁盘分区和逻辑卷/" class="article-date">
      <time datetime="2019-09-09T04:34:30.000Z" itemprop="datePublished">2019-09-09</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/09/09/09-09Linux下的磁盘分区和逻辑卷/">磁盘分区与挂载</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <a id="more"></a>

<p>Linux下的磁盘分区和逻辑卷 </p>
<h2 id="一、硬盘接口类型"><a href="#一、硬盘接口类型" class="headerlink" title="一、硬盘接口类型"></a><strong>一、硬盘接口类型</strong></h2><p>　　硬盘的接口主要有IDE、SATA、SCSI  、SAS和光纤通道等五种类型。其中IDE和SATA接口硬盘多用于家用产品中，也有部分应用于服务器，SATA是一种新生的硬盘接口类型，已经取代了大部分IDE接口应用。SCSI   、SAS主要应用于服务器上，普通家用设备一般不支持SCSI和SAS接口。SAS也是是一种新生的硬盘接口类型，可以和SATA以及部分SCSI设备无缝结合。光纤通道最初设计也不是为了硬盘设计开发的接口，是专门为网络系统设计的，但随着存储系统对速度的需求，才逐渐应用到硬盘系统中，并且其只应用在高端服务器上价格昂贵。</p>
<h2 id="二、硬盘和分区"><a href="#二、硬盘和分区" class="headerlink" title="二、硬盘和分区"></a><strong>二、硬盘和分区</strong></h2><p> 　　Linux中主要有两种分区类型，分别为MBR（Master Boot Record）和GPT（GUID Partition  Table），是在磁盘上存储分区信息的两种不同方式。这些分区信息包含了分区从哪里开始的信息，这样操作系统才知道哪个扇区是属于哪个分区的，以及哪个分区是可以启动的。在磁盘上创建分区时，你必须在MBR和GPT之间做出选择。</p>
<p>　　在Linux中会把设备映射成为一个/dev目录下的系统文件，IDE接口类型的硬盘设备映射的文件名称前缀为“hd”，SCSI、SATA、SAS等接口的硬盘设备映射的文件名称前缀为“sd”（部分虚拟机或者云主机的名称可能是其他的，比如“vd”），后面拼接从“a”开始一直到“z”用来区分不同的硬盘设备，在硬盘名称后面拼接数字形式的分区号用来区分不同的分区。</p>
<h3 id="1、MBR分区"><a href="#1、MBR分区" class="headerlink" title="1、MBR分区"></a><strong>1、MBR分区</strong></h3><p>　　MBR的意思是“主引导记录”，它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。MBR支持最大2TB磁盘，它无法处理大于2TB容量的磁盘。MBR格式的磁盘分区主要分为<strong>基本分区</strong>（primary partion）和<strong>扩展分区</strong>（extension partion）两种<strong>主分区</strong>和扩展分区下的<strong>逻辑分区</strong>。主分区总数不能大于4个，其中最多只能有一个扩展分区。且基本分区可以马上被挂载使用但不能再分区，扩展分区必须再进行二次分区后才能挂载。扩展分区下的二次分区被称之为逻辑分区，逻辑分区数量限制视磁盘类型而定。</p>
<p>　　MBR的主分区号为1-4，逻辑分区号为从5开始累加的数字。比如设备主板上装了4块硬盘，分别为2块IDE接口硬盘，1块SCSI接口硬盘和一块SATA接口硬盘。其中2块IDE接口硬盘的分区策略为2个主分区和2个逻辑分区，SCSI分区策略为3个主分区和3个逻辑分区，SATA分区策略为4个主分区。硬盘文件和分区名称如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>硬盘</th>
<th>主分区1</th>
<th>主分区2</th>
<th>主分区3</th>
<th>主分区4</th>
<th>逻辑分区1</th>
<th>逻辑分区2</th>
<th>逻辑分区3</th>
<th>……</th>
<th>逻辑分区n</th>
</tr>
</thead>
<tbody><tr>
<td>IDE1</td>
<td>/dev/hda</td>
<td>/dev/hda1(p)</td>
<td>/dev/hda2(p)</td>
<td>/dev/hda3(e)</td>
<td>/</td>
<td>/dev/hda5(l)</td>
<td>/dev/hda6(l)</td>
<td>/</td>
<td>……</td>
<td>/</td>
</tr>
<tr>
<td>IDE2</td>
<td>/dev/hdb</td>
<td>/dev/hdb1(p)</td>
<td>/dev/hdb2(p)</td>
<td>/dev/hdb3(e)</td>
<td>/</td>
<td>/dev/hdb5(l)</td>
<td>/dev/hdb6(l)</td>
<td>/</td>
<td>……</td>
<td>/</td>
</tr>
<tr>
<td>SCSI</td>
<td>/dev/sda</td>
<td>/dev/sda1(p)</td>
<td>/dev/sda2(p)</td>
<td>/dev/sda3(p)</td>
<td>/dev/sda4(e)</td>
<td>/dev/sda5(l)</td>
<td>/dev/sda6(l)</td>
<td>/dev/sda7(l)</td>
<td>……</td>
<td>/</td>
</tr>
<tr>
<td>SATA</td>
<td>/dev/sdb</td>
<td>/dev/sdb1(p)</td>
<td>/dev/sdb2(p)</td>
<td>/dev/sdb3(p)</td>
<td>/dev/sdb4(p)</td>
<td>/</td>
<td>/</td>
<td>/</td>
<td>……</td>
<td>/</td>
</tr>
</tbody></table>
<p>其中分区名称后面的（p）代表基本分区，（e）代表扩展分区，（l）代表逻辑分区。需要注意的是，如果分区策略中存在逻辑分区，则说明一定会有扩展分区，那么基本分区数则最多只能有3个，扩展分区数最多只能是1个，如果没有扩展分区则可以创建4个基本分区。想要创建逻辑分区，则必须先将唯一的扩展分区创建出来，并且如果删除了扩展分区，那么它下面的所有逻辑分区也会被自动删除。</p>
<p>　　如果是SCSI接口硬盘则最多只能有15（其中扩展分区不能直接使用所以不计算）个分区，其中主分区最多4个，逻辑分区最多12个。IDE接口硬盘最多只能有63（其中扩展分区不能直接使用所以不计算）个分区，其中主分区最多4个，逻辑分区最多60个。</p>
<h3 id="2、GPT分区"><a href="#2、GPT分区" class="headerlink" title="2、GPT分区"></a><strong>2、GPT分区</strong></h3><p>　　GPT意为GUID分区表，驱动器上的每个分区都有一个全局唯一的标识符（globally unique  identifier，GUID）。支持的最大磁盘可达18EB，它没有主分区和逻辑分区之分，每个硬盘最多可以有128个分区，具有更强的健壮性与更大的兼容性，并且将逐步取代MBR分区方式。GPT分区的命名和MBR类似，只不过没有主分区、扩展分区和逻辑分区之分，分区号直接从1开始累加一直到128。</p>
<h2 id="三、逻辑卷"><a href="#三、逻辑卷" class="headerlink" title="三、逻辑卷"></a><strong>三、逻辑卷</strong></h2><p> 　　LVM（逻辑卷）的产生是因为传统的分区一旦分区好后就无法在线扩充空间，也存在一些工具能实现在线扩充空间但是还是会面临数据损坏的风险；传统的分区当分区空间不足时，一般的解决办法是再创建一个更大的分区将原分区卸载然后将数据拷贝到新分区，但是在企业的生产系统往往不允许停机或者允许停机的时间很短，LVM就能很好的解决在线扩充空间的问题，而且不会对数据造成影响，LVM还能通过快照在备份的过程中保证日志文件和表空间文件在同一时间点的一致性。</p>
<p>　　在LVM中PE(Physical  Extend)是卷的最小单位，默认4M大小，就像我们的数据是以页的形式存储一样，卷就是以PE的形式存储。PV(Physical  Volume)是物理卷，如果要使用逻辑卷，首先第一步操作就是将物理磁盘或者物理分区格式化成PV，格式化之后PV就可以为逻辑卷提供PE了。VG(Volume   Group)是卷组，VG就是将很多PE组合在一起生成一个卷组，当然这里的PE是可以跨磁盘的，如果当前服务器磁盘空间不足就可以增加一个新磁盘对当前系统不会产生任何影响。LV(Logical  Volume)是逻辑卷，逻辑卷最终是给用户使用的，前面几个都是为创建逻辑卷做的准备，创建逻辑卷的大小只要不超过VG剩余空间就可以。</p>
<h2 id="四、文件系统"><a href="#四、文件系统" class="headerlink" title="四、文件系统"></a><strong>四、文件系统</strong></h2><p>　　当硬盘分区被创建完成之后，还并不能直接挂载到目录上存储文件，需要选择合适的文件系统进行格式化。常见的分区类型有FAT32、FAT16、NTFS、HP-UX等，而专供Linux使用的主流的一些分区有ext2/3/4、physical  volume (LVM) 、softwareRAID、swap、vfat、xfs等。其中：</p>
<p>　　1、ext2/3/4：是适合Linux的文件系统类型，由于ext3文件系统多了日志记录功能，因此系统恢复起来更加快速，ext4是ext3的升级，效率更加高，因此建议使用默认类型ext4类型，而不要使用ext2/3；</p>
<p>　　2、physical volume (LVM)：这是一种弹性调整文件系统大小的机制，即可以让文件系统变大或变小，而不改变原文件数据的内容，功能不错，但性能不佳。</p>
<p>　　3、softwareRAID：利用Linux系统的特性，用软件仿真出磁盘阵列功能。</p>
<p>　　4、swap：就是内存交换空间。由于swap并不会使用到目录树的挂载，因此用swap就不需要指定挂载点。</p>
<p>　　5、vfat：同时被Linux与windows所支持的文件系统类型。如果主机硬盘同事存在windows和linux两种操作系统，为了进行数据交换，可以使用该文件系统。</p>
<p>　　6、xfs：也是一个文件系统类型，在centos7中将被作为默认的文件系统类型，替换ext4。</p>
<p><a href="https://www.cnblogs.com/lbole/p/8904298.html" target="_blank" rel="noopener">https://www.cnblogs.com/lbole/p/8904298.html</a></p>
<h2 id="五、使用fdisk操作分区"><a href="#五、使用fdisk操作分区" class="headerlink" title="五、使用fdisk操作分区"></a><strong>五、使用fdisk操作分区</strong></h2><p>　　本文主要以CentOS 7发行版的Linux作为实验，我们使用Fdisk工具来操作分区，Fdisk 是各种 Linux 发行版本中最常用的分区工具。</p>
<p>　　首先输入 fdisk -h 命令查看帮助信息：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localnat201 ~]# fdisk -h</span><br><span class="line">用法：</span><br><span class="line">fdisk [选项] &lt;磁盘&gt; 更改分区表</span><br><span class="line">fdisk [选项] -l &lt;磁盘&gt; 列出分区表</span><br><span class="line">fdisk -s &lt;分区&gt; 给出分区大小(块数)</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">-b &lt;大小&gt; 扇区大小(512、1024、2048或4096)</span><br><span class="line">-c[=&lt;模式&gt;] 兼容模式：“dos”或“nondos”(默认)</span><br><span class="line">-h 打印此帮助文本</span><br><span class="line">-u[=&lt;单位&gt;] 显示单位：“cylinders”(柱面)或“sectors”(扇区，默认)</span><br><span class="line">-v 打印程序版本</span><br><span class="line">-C &lt;数字&gt; 指定柱面数</span><br><span class="line">-H &lt;数字&gt; 指定磁头数</span><br><span class="line">-S &lt;数字&gt; 指定每个磁道的扇区数</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　从中我们可以看出，使用 fdisk -l 命令可查看分区表信息：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@localnat201 ~]# fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：32.2 GB, 32212254720 字节，62914560 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x000b1bc3</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200    62914559    30407680   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：53.7 GB, 53687091200 字节，104857600 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">磁盘 /dev/mapper/cl-root：29.0 GB, 28982640640 字节，56606720 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">磁盘 /dev/mapper/cl-swap：2147 MB, 2147483648 字节，4194304 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　从中我们可以看出，有4个设备，分别为/dev/sda、/dev/sdb、/dev/mapper/cl-root、/dev/mapper/cl-swap。其中/dev/sda硬盘已经有2个分区分区为：/dev/sda1和/dev/sda2。/dev/mapper/cl-root和/dev/mapper/cl-swap两个设备是/dev/sda2分区创建的逻辑卷。这里的/dev/sdb硬盘设备并没有被分区，我们则是需要来操作这个硬盘，至于如何操作逻辑卷后面会讲到。</p>
<p>　　输入 fdisk /dev/sdb 命令，对/dev/sda硬盘的分区表进行操作：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localnat201 ~]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 0xc72a6f6a 创建新的 DOS 磁盘标签。</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　我们输入”m”选项可以查看到帮助信息：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">命令(输入 m 获取帮助)：m</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag 切换可引导标志</span><br><span class="line">   b   edit bsd disklabel 编辑BSD磁盘标签</span><br><span class="line">   c   toggle the dos compatibility flag 切换DOS兼容性标志</span><br><span class="line">   d   delete a partition 删除分区</span><br><span class="line">   g   create a new empty GPT partition table 创建一个新的空GPT分区表</span><br><span class="line">   G   create an IRIX (SGI) partition table 创建一个ILIX（SGI）分区表</span><br><span class="line">   l   list known partition types 列出已知分区类型</span><br><span class="line">   m   print this menu 打印此菜单</span><br><span class="line">   n   add a new partition 添加新分区</span><br><span class="line">   o   create a new empty DOS partition table 创建一个新的空DOS分区表</span><br><span class="line">   p   print the partition table 打印分区表</span><br><span class="line">   q   quit without saving changes 不保存更改退出</span><br><span class="line">   s   create a new empty Sun disklabel 创建一个新的空太阳标签</span><br><span class="line">   t   change a partition&apos;s system id 更改分区的系统ID</span><br><span class="line">   u   change display/entry units 更改显示/输入单元</span><br><span class="line">   v   verify the partition table 验证分区表</span><br><span class="line">   w   write table to disk and exit 将表写入磁盘并退出</span><br><span class="line">   x   extra functionality (experts only) 额外功能（仅专家）命令(输入 m 获取帮助)：</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　从上面的帮助信息中，可以得知一些选项的用途。这里主要注意”d”、”n”、”q”、”g”、”w”等选项。首先要明确分区格式，fdisk默认的分区格式是msdos（mbr），在此可输入”g”选项，将分区格式修改为GPT，不过在修改完保存退出之后，在输入 fdisk /dev/sdb 命令进入分区模式，会出现 WARNING: fdisk GPT support is currently new, and therefore in an experimental phase. Use at your own discretion. 信息，提示fdisk gpt分区是新的功能，目前还在实验阶段。所以如果要进行GPT分区，那么推荐使用 parted 命令，后面会介绍到。</p>
<p>　　那么首先输入”n”选项来开始创建分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):</span><br></pre></td></tr></table></figure>

<p>　　可以看到交互界面打印的信息，提示需要选择一个分区类型，”p”:为基本分区（默认）；”e”：为扩展分区。在此我们选择”p”，创建一个基本分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Partition type:p primary (1 primary, 0 extended, 3 free)e extendedSelect (default p): p</span><br><span class="line">分区号 (2-4，默认 2)：</span><br></pre></td></tr></table></figure>

<p>　　交互界面提示需要选择一个分区号，范围为2-4。由于已经存在了一个基本分区，所以只可选择2、3、4（默认2，顺序累加）。在此我们输入2：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Partition type:<br>   p   primary (1 primary, 0 extended, 3 free)<br>   e   extended<br>Select (default p): p<br>分区号 (2-4，默认 2)：2<br>起始 扇区 (2099200-314572799，默认为 2099200)：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　可以看到交互界面提示序号选择其实扇区，默认为剩余未被分配的最小扇区，推荐选择默认（直接点击回车）；</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (2-4，默认 2)：2</span><br><span class="line">起始 扇区 (2099200-314572799，默认为 2099200)：</span><br><span class="line">将使用默认值 2099200</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2099200-314572799，默认为 314572799)：</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　交互界面提示，要输入需要分配的截止扇区，默认为未被分配的最小扇区，此处推荐默认（直接点击回车）：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (2-4，默认 2)：2</span><br><span class="line">起始 扇区 (2099200-314572799，默认为 2099200)：</span><br><span class="line">将使用默认值 2099200</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2099200-314572799，默认为 314572799)：</span><br><span class="line">将使用默认值 314572799</span><br><span class="line">分区 2 已设置为 Linux 类型，大小设为 149 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　可以看到又回到了最初的交互界面，这表示分区表已经设置成功，输入选项q表示要放弃本次分区表的修改并退出，w选项表示保存本次分区表的修改并退出，此处选择w表示将分区信息写入到磁盘，此次分区完成；</p>
<p>　　回到最初操作分区表的地方，选择”d”选项，删除分区的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令(输入 m 获取帮助)：d</span><br><span class="line">分区号 (1,2，默认 2)：</span><br></pre></td></tr></table></figure>

<p>　　交互界面提示输入要删除的分区的分区号，此处选择2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令(输入 m 获取帮助)：d</span><br><span class="line">分区号 (1,2，默认 2)：2</span><br><span class="line">分区 2 已删除</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：</span><br></pre></td></tr></table></figure>

<p>　　交互界面提示本次分区表操作成功，输入选项”w”，表示将分区信息写入到磁盘，此次删除分区完成。回到最初选择分区类型的地方，选择”e”，创建扩展分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e</span><br><span class="line">分区号 (2-4，默认 2)：</span><br></pre></td></tr></table></figure>

<p>　　交互界面提示要输入扩展分区的分区号，可选范围为2-4，此处选择2：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e</span><br><span class="line">分区号 (2-4，默认 2)：2</span><br><span class="line">起始 扇区 (2099200-314572799，默认为 2099200)：</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　交互界面提示输入要分配给扩展分区的起始扇区，此处选择默认：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e</span><br><span class="line">分区号 (2-4，默认 2)：2</span><br><span class="line">起始 扇区 (2099200-314572799，默认为 2099200)：</span><br><span class="line">将使用默认值 2099200</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2099200-314572799，默认为 314572799)：</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　交互界面提示输入要分配给扩展分区的截止扇区，此处选择默认：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e</span><br><span class="line">分区号 (2-4，默认 2)：2</span><br><span class="line">起始 扇区 (2099200-314572799，默认为 2099200)：</span><br><span class="line">将使用默认值 2099200</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2099200-314572799，默认为 314572799)：</span><br><span class="line">将使用默认值 314572799</span><br><span class="line">分区 2 已设置为 Extended 类型，大小设为 149 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　交互界面提示本次对分区表的操作已完成，输入”w”选项，保存本次对分区表的操作；当再次创建分区的时候，交互界面就会将扩展分区的选项”e”替换成为逻辑分区的选项”l”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p):</span><br></pre></td></tr></table></figure>

<p>　　之后再要创建逻辑分区和之前创建分区的步骤一直，分区完成。至此CentOS中的分区操作已完成；接下来我们需要将物理分区格式化成某一个文件系统，我们使用mkds进行分区格式化操作，输入 mkfs -h 命令获取帮助信息：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -h</span><br><span class="line">用法：</span><br><span class="line"> mkfs [选项] [-t &lt;类型&gt;] [文件系统选项] &lt;设备&gt; [&lt;大小&gt;]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"> -t, --type=&lt;类型&gt;  文件系统类型；</span><br><span class="line">     fs-options     实际文件系统构建程序的参数</span><br><span class="line">     &lt;设备&gt;         要使用设备的路径</span><br><span class="line">     &lt;大小&gt;         要使用设备上的块数</span><br><span class="line"> -V, --verbose      解释正在进行的操作；</span><br><span class="line">                      多次指定 -V 将导致空运行(dry-run)</span><br><span class="line"> -V, --version      显示版本信息并退出</span><br><span class="line">                      将 -V 作为 --version 选项时必须是惟一选项</span><br><span class="line"> -h, --help         显示此帮助并退出</span><br><span class="line"></span><br><span class="line">更多信息请参阅 mkfs(8)。</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　从帮助信息中我们可以看到，可以使用mkfs -t xfs /dev/sdb1 进行格式化分区：</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localnat201 ~]# mkfs -t xfs /dev/sda2 </span><br><span class="line">meta-data=/dev/sdb1              isize=512    agcount=4, agsize=624936 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=2499744, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal log           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　格式化成xfs时，若提示分区已存在文件系统，则需要在分区前面加上-f选项强行覆盖，例如： mkfs -t xfs -f /dev/sda2 。被格式化的设备既可以是分区，也可以是逻辑卷。要查看所有分区的文件系统格式则可以使用 df -Th 命令。至此格式化分区完成。分区格式化完成之后则可以将分区挂载到某一个目录下面，正式开始使用改分区，我们在系统中创建一个用户挂载分区的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /data</span><br></pre></td></tr></table></figure>

<p>　　将分区挂载到目录上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda2 /data/</span><br></pre></td></tr></table></figure>

<p>　　设置开机自动挂载分区到挂载点，编辑 vim /etc/fstab :</p>
<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># /etc/fstab</span><br><span class="line"># Created by anaconda on Sun Jun 25 07:16:25 2017</span><br><span class="line">#</span><br><span class="line"># Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;</span><br><span class="line"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span><br><span class="line">#</span><br><span class="line">UUID=eb697457-a097-4263-8bbf-a75aa632d27c /                       ext4    defaults        1 1</span><br><span class="line"></span><br><span class="line">/dev/sda2                               /data                   xfs    defaults        0 0</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　如果想要卸载挂载点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localnat201 ~]# umount /dev/sda2</span><br></pre></td></tr></table></figure>

<p>　　至此挂载分区已完成；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统安全/">系统安全</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-08-09网络连接" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/09/08/08-09网络连接/" class="article-date">
      <time datetime="2019-09-08T09:42:20.000Z" itemprop="datePublished">2019-09-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/09/08/08-09网络连接/">网络连接</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <a id="more"></a>

<p>网络安全：</p>
<h1 id="一、主机名的配置（配置文件-etc-hostname）"><a href="#一、主机名的配置（配置文件-etc-hostname）" class="headerlink" title="一、主机名的配置（配置文件/etc/hostname）"></a>一、主机名的配置（配置文件/etc/hostname）</h1><h2 id="1、使用-hostname-命令临时设置主机名"><a href="#1、使用-hostname-命令临时设置主机名" class="headerlink" title="1、使用 hostname 命令临时设置主机名"></a>1、使用 hostname 命令临时设置主机名</h2><p>  命令格式：hostname [新主机名] </p>
<h2 id="2．永久设置主机名"><a href="#2．永久设置主机名" class="headerlink" title="2．永久设置主机名"></a>2．永久设置主机名</h2><p> 命令格式：hostnamectl set-hostname 新主机名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost guest1]# hostname</span><br><span class="line">localhost.localdomain</span><br><span class="line">[root@localhost guest1]# hostnamectl set-hostname xuelian</span><br><span class="line">[root@localhost guest1]# hostname</span><br><span class="line">xuelian</span><br></pre></td></tr></table></figure>

<p>重启之后 进入命令行界面，并且使用等级转换不了</p>
<p><img src="https://ws1.sinaimg.cn/large/007ru3v0gy1g6shv6rhszj309g02nweb.jpg" alt="\img"></p>
<h1 id="二、网卡信息的配置"><a href="#二、网卡信息的配置" class="headerlink" title="二、网卡信息的配置"></a>二、网卡信息的配置</h1><h2 id="1、网卡配置文件"><a href="#1、网卡配置文件" class="headerlink" title="1、网卡配置文件"></a>1、网卡配置文件</h2><p>位于:/etc/sysconfig/network-scripts 目录下,一块网卡对应一个配置文件。<strong>ifcfg-ens33</strong>为网卡配置文件，常用配置项的含义如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=ens33 //定义该网卡的识别名称。</span><br><span class="line"></span><br><span class="line">BOOTPROTO=dhcp //启动该网卡的方式，dhcp 表示通过 BOOTP 或 DHCP 协议动态取得 IP 地址。 </span><br><span class="line">ONBOOT=yes //启动 network 服务时，是否启动该网卡。</span><br><span class="line"></span><br><span class="line">TYPE=Ethernet //网卡的类型。 </span><br><span class="line"></span><br><span class="line">IPADDR=192.168.64.128 //静态方式指定网卡的 IP 地址 </span><br><span class="line"></span><br><span class="line">NETMASK=255.255.255.0 //定义网卡的子网掩码 </span><br><span class="line"></span><br><span class="line">MTU=1500 //网卡传输的最大数据包 </span><br><span class="line"></span><br><span class="line">GATEWAY=192.168.64.254 //网络的默认网关 </span><br><span class="line">DNS1=</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=eth0</span><br><span class="line">IPADD=192.168.199.129</span><br><span class="line">DNS1=192.168.199.2</span><br><span class="line">UUID=74f0b9ff-58d8-4166-add5-710e912ba2e5</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=no</span><br><span class="line">ZONE=</span><br></pre></td></tr></table></figure>

<h2 id="2、配置网卡信息"><a href="#2、配置网卡信息" class="headerlink" title="2、配置网卡信息"></a>2、配置网卡信息</h2><h3 id="（1）直接修改网卡配置文件"><a href="#（1）直接修改网卡配置文件" class="headerlink" title="（1）直接修改网卡配置文件"></a>（1）直接修改网卡配置文件</h3><p> #vim /etc/sysconfig/network-scripts ifcfg-ens33 </p>
<p>修改完成后重启服务才生效 #systemctl restart network.service </p>
<h3 id="（2）ifconfig-命令"><a href="#（2）ifconfig-命令" class="headerlink" title="（2）ifconfig 命令"></a>（2）ifconfig 命令</h3><p> ①查看网卡信息 命令格式：ifconfig [选项] </p>
<p>​     无选项：显示当前活动的网卡。</p>
<p>   –a ：显示系统中所有网卡配置信息。 </p>
<p>   网卡设备名：显示指定网卡配置信息。</p>
<p>②设置 IP 地址（临时的） </p>
<p>   命令格式：ifconfig 网卡设备名 IP 地址 netmask 子网掩码 </p>
<p>③ 修改网卡的 MAC 地址（先禁用网卡，修改后重启网卡） </p>
<p>   命令格式：ifconfig 网卡设备名 hw ether MAC 地址</p>
<h3 id="（3）网卡常用命令"><a href="#（3）网卡常用命令" class="headerlink" title="（3）网卡常用命令"></a>（3）网卡常用命令</h3><p>① ifdown（禁用网卡） </p>
<p>命令格式：ifdown 网卡设备名</p>
<p>② ifup（重启网卡） </p>
<p>命令格式：ifup 网卡设备名 </p>
<p>③绑定 IP 和 MAC 地址 </p>
<p>【举例】创建/etc/ethers 文件，将 193.168.168.154 与 00：0C：29：03：F3：75 网卡绑定。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo “193.168.168.154 00：0C：29：03：F3：75” &gt;&gt;/etc/ethers #arp -f</span><br></pre></td></tr></table></figure>

<h1 id="三、客户端域名解析服务器的配置"><a href="#三、客户端域名解析服务器的配置" class="headerlink" title="三、客户端域名解析服务器的配置"></a>三、客户端域名解析服务器的配置</h1><p>在 Linux 系统中客户端域名解析服务器的配置文件是<strong>/etc/resolv.conf</strong></p>
<p>文件内容格式：nameserver 指定 DNS 服务器的 IP 地址。 </p>
<p>最多可同时指定 3 个 DNS 服务器的 IP 地址，根据 nameserver 的配置顺序决定搜索。可 以使用 domain 来指定当前主机所在域的域名。 </p>
<p>为 避 免 /etc/resolv.conf 文 件 的 内 容 被 系 统 修 改 或 覆 盖 ， 需 要 修 改 /etc/NetworkManager/NetworkManager.conf 文件，在 main 部分添加“dns=none”选项。 </p>
<p>修改后的 NetworkManager.conf 文件的内容如下所示： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main] </span><br><span class="line"></span><br><span class="line">plugins=ifcfg-rh </span><br><span class="line"></span><br><span class="line">dns=none</span><br></pre></td></tr></table></figure>

<p>在完成修改后，需要执行命令：</p>
<p> #systemctl restart NetworkManager.service </p>
<p>重新装载 NetworkManager 的配置。此时客户端域名解析服务器设置完成</p>
<h1 id="四、常用网络调试命令与故障排查"><a href="#四、常用网络调试命令与故障排查" class="headerlink" title="四、常用网络调试命令与故障排查"></a>四、常用网络调试命令与故障排查</h1><h2 id="1．-ping-命令"><a href="#1．-ping-命令" class="headerlink" title="1．*ping *命令"></a>1．*<em>ping *</em>命令</h2><p>测试网络中是否畅通以及网络质量。 </p>
<p>命令格式：*<em>ping [选项] 对方 IP 地址 *</em></p>
<p>选项说明： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c : 指定向目的主机发送多少个报文。 </span><br><span class="line"></span><br><span class="line">-s :指定发送报文的大小，以字节为单位。</span><br><span class="line"></span><br><span class="line"> -W: 设置等待接收回应报文的时间间隔，以秒为单位。</span><br></pre></td></tr></table></figure>

<h2 id="2．netstat-命令："><a href="#2．netstat-命令：" class="headerlink" title="2．netstat 命令："></a>2．<strong>netstat</strong> 命令：</h2><p>显示网络连接、路由表、正在监听的端口等信息。 </p>
<p>命令格式：netstat [选项] 选项说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> -l : 显示正在监听的服务或端口。</span><br><span class="line"></span><br><span class="line">-a : 显示当前主机开放的所有端口 </span><br><span class="line"></span><br><span class="line">-n : 不进行域名解析。 </span><br><span class="line"></span><br><span class="line">-p : 显示端口是由哪个进程和程序在监听。</span><br><span class="line"></span><br><span class="line"> -c : 动态显示网络连接和端口监听信息。 </span><br><span class="line"></span><br><span class="line">-i : 显示网卡相关信息。 </span><br><span class="line"></span><br><span class="line">-r : 显示当前主机的路由表信息。</span><br></pre></td></tr></table></figure>

<h2 id="3．traceroute-命令：路由跟踪。"><a href="#3．traceroute-命令：路由跟踪。" class="headerlink" title="3．traceroute 命令：路由跟踪。"></a>3．<strong>traceroute</strong> 命令：路由跟踪。</h2><p>命令格式：*<em>traceroute 目的 IP 地址 *</em></p>
<h2 id="4．nslookup-命令"><a href="#4．nslookup-命令" class="headerlink" title="4．nslookup 命令"></a>4．<strong>nslookup</strong> 命令</h2><p>检测指定的 DNS 服务器工作是否正常 </p>
<p>命令格式：nslookup</p>
<h1 id="课程小结"><a href="#课程小结" class="headerlink" title="课程小结"></a>课程小结</h1><p>1、主机名与网卡信息的配置 </p>
<p>2、客户端域名解析服务器的配置 </p>
<p>3、网络故障排查方法</p>
<h1 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h1><p>1、 临时设置主机名为：myhost。 </p>
<p>2、 设置网卡信息： IP地址为202.137.5.6，网关是202.137.5.1，子网掩码是255.255.255.0， 设置域名解析服务器为 216.128.5.132。 </p>
<p>3、 对每一步的设置，管理员都要做相应的查看以确认设置是否成功。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统安全/">系统安全</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-应急响应笔记大纲" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/09/08/应急响应笔记大纲/" class="article-date">
      <time datetime="2019-09-08T08:00:57.133Z" itemprop="datePublished">2019-09-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="https://bypass007.github.io/Emergency-Response-Notes/Summary/image/sum-title.png" alt></p>
<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>面对各种各样的安全事件，我们该怎么处理？</p>
<p>这是一个关于安全事件应急响应的项目，从系统入侵到事件处理，收集和整理了一些案例进行分析。</p>
<p>我将持续更新这份笔记，希望能帮到有需要的人。</p>
<h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><ul>
<li><p><strong>[第一章：应急响应]</strong></p>
</li>
<li><p>第1篇:Window入侵排查</p>
</li>
<li><p>第2篇:Linux入侵排查</p>
</li>
<li><p><strong>[第二章：日志分析]</strong></p>
<ul>
<li><p>第1篇:Window日志分析</p>
<ul>
<li>第2篇:Linux日志分析 </li>
</ul>
</li>
</ul>
</li>
<li><p>第3篇:Web日志分析</p>
</li>
<li><p>第4篇:MSSQL日志分析 </p>
<ul>
<li>第5篇:MySQL日志分析</li>
</ul>
</li>
<li><p><strong>[第三章:Windows实战篇]</strong></p>
<ul>
<li><p>第1篇：FTP暴力破解</p>
</li>
<li><p>第2篇：蠕虫病毒</p>
</li>
<li><p>第3篇：勒索病毒</p>
</li>
<li><p>第4篇：ARP病毒</p>
</li>
<li><p>第5篇：挖矿病毒（一）</p>
</li>
<li><p>第6篇：挖矿病毒（二）</p>
</li>
</ul>
</li>
<li><p><strong>[第四章：Linux实战篇]</strong></p>
<ul>
<li><p>第1篇：SSH暴力破解</p>
</li>
<li><p>第2篇：捕捉短连接</p>
</li>
<li><p>第3篇：挖矿病毒</p>
</li>
<li><p>第4篇：盖茨木马</p>
</li>
<li><p>第5篇：DDOS病毒</p>
</li>
<li><p>第6篇：Shell病毒</p>
</li>
</ul>
</li>
<li><p><strong>[第五章：Web实战篇]</strong></p>
<ul>
<li><p>第1篇：网站被植入Webshell</p>
</li>
<li><p>第2篇：门罗币恶意挖矿</p>
</li>
<li><p>第3篇：批量挂黑页</p>
</li>
<li><p>第4篇：新闻源网站劫持</p>
</li>
<li><p>第5篇：移动端劫持</p>
</li>
<li><p>第6篇：搜索引擎劫持</p>
</li>
<li><p>第7篇：网站首页被篡改</p>
</li>
<li><p>第8篇：管理员账号被篡改</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 Lei Xuelian
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>